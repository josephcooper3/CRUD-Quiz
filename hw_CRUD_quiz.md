# CRUD Quiz

Use the solution to this afternoon's Property Tracker lab to answer the following questions. Please write your answers under each question, push the file to GitHub, and submit in the usual way.

## MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the `Property` class?

A. In the `console.rb` file using the Property.new method, for example:
```
property1 = Property.new({
  'address' => '89 Bouverie Road, WESTON UNDER WETHERLEY, CV33 3XG',
  'value' => 120000,
  'bedrooms' => 3,
  'build' => 'detached'
  })
```

Q2. Where are we defining the SQL that enables us to save the ruby `Property` object into the database?

A. In a variable `sql` inside the method `save` in the models/property.rb file, for example:
```
sql = "INSERT INTO properties
(
  address,
  value,
  bedrooms,
  build
)
VALUES
(
  $1,$2,$3,$4
)
RETURNING id"
  ```

Q3. In `console.rb`, which lines modify the database?

```
Property.delete_all()
property1.save()
property2.save()
property3.save()
property1.delete()
```

Q4. Why do we not define the id of a `Property` object at the point we instantiate it (‘new it up’)?

A. To ensure that every id is unique. If it is not defined by the Ruby programme, it can be left to be allocated uniquely by the database (using SERIAL4).

Q5. Where and how do we assign the id (that is generated by the database) to the ruby `Property` object?

A. First this is returned by the RETURN line and the end of the SQL statement in the `.save` method:
```
RETURNING id
```

Then the following line of code assigns it to the instance's variable `@id` (see also Q8 below):
```
@id = db.exec_prepared("save", values)[0]["id"].to_i
```

Q6. Why do we put a guard (an `if` clause) on the `@id` attribute in the constructor?

A. So that it is left blank at the point the object is instantiated, allowing it to be allocated uniquely by the database. This then means that once it is read from the database it can be stored at this point so it stays unique.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

A. `.save`, `.update` and `.delete` need to be instance methods because they affect a specific instance. `.delete_all` and `.all`, on the other hand, need to be class methods because by design they delete or read every instance of the class. `.find` and `.find_by_address` also need to read the whole class because by design they search through every instance - the user does not know which instances will match their search.

Q8. What type of data structure is returned by calls to `db.exec_prepared()`? In the `save` method, how do we access the id from the returned data structure?

A. It is returned in an array-like structure. We then access this using the `[0]` index and then the `["id"]` key, finally converting the returned string to an integer with .to_i .

Q9. Why do we use prepared statements when performing database operations?

A. To prevent the possibility of an SQL injection attack, where a user could insert an SQL command such as `; DROP TABLE` into a variable and this could then delete data.

## Extension Questions

Look at the `find_by_id` and `find_by_address` methods in the `Property` class.

Q10. What do they take in as their arguments?

A. `find_by_id` takes in the value of the id key of the property to search for, i.e. an integer. `find_by_address` takes in the value of the address key of a property to search for, i.e. a string.

Q11. What are their return values?

A. Each of the methods returns an instance of the Property class containing a hash, which itself contains the data from the SQL database that matched the search. This means it is being returned in the same format that new instances are created in. It is only returning one result per search (evidenced by the `[0]` index).
